    Oh Most Noble and Virile Emacs, please be in -*- outline-*- mode!

     Inversion: A Version Control System You Actually Want To Use
     ------------------------------------------------------------
              ($Revision: 1.2 $ of this document.)

* Introduction

This document describes Inversion, a replacement for CVS.  We may
sometimes call it "Ivn", to save space.  It will be described largely
in terms of how it differs, or doesn't differ, from CVS; if you don't
already know CVS, this document will be pretty unreadable.

Where you see the word "version", it means the same thing "revision"
does in the CVS documentation.  Everyone always ends up saying
"version" anyway, then correcting themselves, so let's just give up
already.  Besides, it's shorter to type.

"Project" and "Repository" also mean what you think they do -- a
repository is a place where multiple projects are stored.  Sometimes I
might slip and say "repository" where I should have said "project",
because CVS uses the r-word for both.  Bear with me.

* Requirements

** All CVS features are supported.

Everything CVS has, we want.  Versioning, folding of non-conflicting
changes, detection of conflicting changes, branching, merging,
historical diffs, log messages, line-by-line history ("cvs annotate"),
the works.

Generally, Inversion's conceptual interface to a particular feature
will be as similar to CVS's as possible, except when there's a
compelling reason to do otherwise.

** Version numbers are project-wide and atomic.

Unlike CVS, each Inversion commit results in a single new version
number, which applies to the project as a whole (i.e., it applies to
every object in the project, whether changed or not).  There are no
longer separate per-file version numbers, at least not user-visible
ones.

Commits are atomic -- either the entire commit succeeded, or the
entire commit failed.  No one can ever retrieve a project tree in an
inconsistent state.

A commit may block on another commits (though only briefly, and only
when absolutely necessary -- that is, when the same files would be
affected).  But readers never cause locks nor wait for locks.  The
repository is always readable.

** Directories, renames, and file meta-data are versioned.

Naturally!

By the way, rename support means you can trace through ancestry by
name <i>or</i> by entity.  For example, if you say "Give me version 12
of foo.c", you might mean version 12 of the file whose name is
<i>now</i> foo.c (but perhaps it was named bar.c back at version 12),
or you might mean the file whose name was foo.c in version 12 (perhaps
that file no longer exists, or has a different name now).  Inversion
offers a way to specify which interpretation you want, while
defaulting to the most reasonable interpretation in context.  We
haven't decided what "reasonable" means yet, but we're working on
that.

** Binary files are handled just like anything else.

That's right, no more "-kb" flag. <tt>:-)</tt>

Whether Inversion is able to merge changes into a file gracefully, or
show diffs, depends on whether diffing and/or merging tools are
defined for that type of file.  Right now, we know that text files are
supported.  (How does Inversion know whether something's text file or
not?  Well, you can tell it the type explicitly, or ask it to deduce
on the fly.)

Also, for text files, Inversion can do platform-specific end-of-line
conversion (CRLF vs LF, etc), just like CVS.

Regarding keyword expansion: Inversion does support it, but only on
request.  By default, keyword expansion is off -- if you do not ask
for expansion for a given file or group of files, Inversion will not
modify content.

** I18N/Multilingual support: non-ASCII encodings can be treated as text.

Inversion does not assume that anything not 7-bit ASCII must therefore
be opaque binary -- it tries very hard to treat things as UTF-* text,
for purposes of diffing and annotation, whenever possible.

** Branching and tagging are constant-time operations in Inversion.

CVS makes an unnecessary distinction between branches and tags, and
then goes on to implement them in an inefficient way.

Inversion supports them both with one efficient operation: `copy'.  To
copy a project is to create another project exactly like it, except
that the new project "knows" that the old project is its ancestor.
Version numbers in the new project start at the ancestor's version
number.

Clearly, at the moment of creation, a copy requires only a tiny amount
of constant space -- the copy is like an "alias" for the old project.
And if you never commit anything on the copy, then it's just like a
CVS tag.

If you start committing on the copy, then it's a branch.  Voila!

By default, inversion uses per-project namespaces for copies, to avoid
cross-project name conflicts.

[Thanks to Jim Blandy &lt;jimb@red-bean.com&gt; for pointing out that
`copy' is a clean way to get both tagging and branching.]

** Repeated merges are handled gracefully.

Inversion merges are the same, in principle, as CVS merges: merging
means taking the differences between version A and B, and applying
those differences as a patch to version X (which may simply be the
working copy, rather than a formal repository version).

BUT, Ivn remembers what has already been merged, and doesn't merge
anything twice unless forced to.  So if you merge the differences
between &lt;Branch A, Version N&gt; and &lt;Branch A, Tip&gt; into
&lt;Branch B&gt;, and then you do it again a month later, the second
merge will only get the changes from &lt;Branch A, Previous Tip&gt; to
&lt;Branch A, Current Tip&gt;, <i>not</i> from &lt;Branch A, Version
N&gt; to &lt;Branch A, Current Tip&gt;.

<i>This will require a more complete specification, of course, but
above is the general idea.  Note that per-object merge records will
need to be maintained on the server side, since people often need to
merge project subsets.</i>

** Inversion does not set log message policy.

A small matter, but one dear to our hearts...

Log messages are a matter of project policy, not VC software policy.
If you leave off a log message, then Inversion defaults to an empty
message -- unless the project admin sets the right bit, in which case
log messages will be required <i>for that project only</i>.

(CVS tries to require log messages, but fails: we've all seen
thousands of empty log messages in CVS, where the user did
<tt>commit&nbsp;-m&nbsp;""</tt> or whatever, so let's please stop the
madness now.)

** Conflicts do not munge working files (unless requested).

CVS's conflict resolution mechanism folds repository changes into the
working files, even when they conflict with changes there.  This is
often winning, in text files, but it doesn't work for binary files and
sometimes it's not so great for text either.

Inversion only does it that way if asked to; otherwise, it puts the
repository version of the file somewhere nearby, and the user can use
whatever comparison tools she wants to resolve the conflict.  When
Inversion <i>does</i> munge the working file, it first preserves an
unmunged copy somewhere nearby, in case the user regrets the update.

Inversion can optionally make educated guesses about what's binary and
what's text, so the user gets the right conflict resolution mechanism
for the context.

** Support for plug-in client-side diff programs

There is no need for Inversion to have every possible diff mechanism
built in (or even any mechanism built in).  Instead, it invokes the
appropriate client-side diff'er on the two versions of the file(s)
locally.  For text files, the appropriate diff'er is the system `diff'
program, or maybe "emacs -f ediff".  For image files, it might be some
fancy visual comparison product.

Maybe if no good client-side program is available, Ivn can get
sophisticated and send the working file to the server, who will try to
do the diff and send it back.  But that's for the future.

* Implementation

** Repository uses diffy storage, of course.

The Ivn repository does diff storage like CVS, with the full-text of
most recent version of a file, and then reverse diffs going back in
time.  But Ivn does not use RCS format, and it uses a binary differ of
course (XDelta?), not a text differ.

In order to preserve the "cvs annotate" information, line-number
change information is stored along with the binary diff.  [Thanks
again to Jim Blandy for this trick.]

** Natively client/server.

Even when accessing a local repository, the ivn client connects to a
ivn server and talks the ivn protocol.  This is for maintainability --
in CVS, it's easy to write a bug by implementing something correctly
for either the client/server or the standalone but not both (and more
often neither, but that's another story).

The protocol may be DAV, if DAV turns out to be suitable.  Still under
investigation.

** The client/server protocol sends diffs in both directions

Inversion transmits diffs both ways (unlike CVS, which transmits diffs
from server to client, but full files going the other way, thus using
more bandwidth than necessary).  Ivn accomplishes this either by
keeping pristine copies locally, or using the rsync algorithm; which
way we do it is an implementation detail that hasn't been decided yet.

** The server stores projects in a database

It turns out that project history storage falls neatly into a
relational model; furthermore, using a real database gives us a lot of
the locking behavior we need for free, and allows us to speed up
crucial read operations by creating the right indexes.

In short, this is one wheel we don't want to reinvent.

A database makes it easy to have multiple repositories on one machine,
with different admins for each repository -- each repository is simply
a database (i.e., a namespace within which one can create tables) in
the system.  Ultimate admin permissions are obtained through the usual
database administration entry points.

** Data design

So what's the "thingum" in this database, the core object (i.e, table)
around which everything else revolves?  For lack of a better name,
we'll call it the "entity" table, where "entity" means a file or
directory that's under version control.

A look at its table description below will make things clearer...

*** The ENTITIES table

     PKEY         int           Internal unique identifier for this
                  (never null)  entity. Users never see the pkey,
                                only people trying to debug a problem
                                in Inversion.
     NAME         string        The name of this file or directory (a
                                basename). Of course, this is only
                                the name in this version. Names are
                                versioned like anything else.

                                If null, then this version's state
                                (see below) must be "dead" or
                                something similar.
     PROJECT      int [fkey]
                  (never null)  Foreign key into the projects table.
     VERSION      int           What version of the project this row
                  (never null)  is associated with.

                                Remember that every other entity in
                                this commit has the same version
                                number.
     NEXT_VERSION int           The next different version of this
                                entity.

                                Null means there is no different
                                future version. (?)
     PREV_VERSION int           The previous different version of
                                this entity (i.e., not necessarily
                                VERSION - 1). May cross projects (see
                                the `ancestor' column in the
                                `projects' table).

                                Null means this is the first version
                                of this entity.
     STATE        string        The state of this entity. This is
                  (never null)  primarily for death and resurrection
                                support, but may also be used to
                                record other states, if we can think
                                of any.
     CONTENTS     text          The contents of this version of the
                                entity.

                                If this row is at the most recent
                                version in the project, then this is
                                simply the full contents of the
                                object: in the case of a regular
                                file, then obviously it's the file's
                                contents; if a directory, then it's a
                                list (format to be determined) of the
                                entities in the directory; if a
                                symlink, the target of the symlink;
                                if device, the device parameters; and
                                so on.

                                If this is not the most recent
                                version, then the "contents" are
                                stored as a reverse binary diff from
                                the contents of the next version. For
                                directories, that diff is a list of
                                adds, deletes, and renames (again,
                                format details to be determined).

                                Null means this version does not
                                differ from the next version.
     LINE_MODS    text          For text files, change line-numbers
                                are recorded (as for text diffs), so
                                that deriving "cvs annotate"
                                information is cheap.

                                Null means this information is
                                unavailable or not applicable.
     TYPE         string        Regular file, or directory, or
                  (never null)  symlink, or hard link, or device,
                                etc.
     PROPERTIES   text          Meta-data, stored in a format to be
                                determined (probably key=value pairs,
                                like environment strings). This is
                                how permission information is
                                preserved, among other things.

                                Null means there are no properties,
                                though this is probably rare.
     PARENT_DIR   int [pkey]    The parent entity of this entity, in
                                this version (it had better be a
                                directory!).

                                Null means this is the root entity.

                                Note: this way of recording
                                tree-structure is questionable;
                                certain operations (tree-building!)
                                might be too expensive if we do
                                things this way. Another possibility
                                is that the `name' column is not a
                                basename, but a complete relative
                                path within the project. Still
                                thinking about this issue; see the
                                Meta-Implementation section farther
                                down.
     MERGE_METHOD string        The name of a merge method that
                                Inversion understands (right now
                                Inversion only knows how to do text
                                merges.) Normally, merging is only
                                possible between two versions which
                                are of the same TYPE.

                                Null means merges are not possible
                                with this entity.

*** The PROJECTS table

     PKEY            int               Internal unique identifier for
                                       this project. Users never see
                                       the pkey, only people trying
                                       to debug a problem in
                                       Inversion.

                                       This pkey may actually not be
                                       necessary; if not, then note
                                       that the `project' column in
                                       the `entities' table (see
                                       above) would reference
                                       projects by name (string)
                                       instead of fkey (int).
     NAME            string            The name of this project.
     DESCRIPTION     string            What's this project all about
                                       (for anon accessors).
     HIGHEST_VERSION int               Just what you think it is.
                     (never null)      Also known as the "tip".
     LOWEST_VERSION  int               Also what you think it is.
                     (never null)      Usually 1, but could be higher
                                       for projects with a non-null
                                       ancestor.
     ANCESTOR        int [fkey] or     If not null, then this project
                     string            is a "copy" (tag or branch) of
                                       some other project.

                                       One reason to use a string
                                       instead of an fkey would be to
                                       allow off-site ancestors. This
                                       would enable private,
                                       third-party branching -- way
                                       cool, although a few other
                                       things in this design would
                                       need to be tweaked to allow
                                       for that. We'll make sure that
                                       happens in the second design
                                       pass; this is still a rough
                                       draft.

                                       Also, debugging gets easier
                                       the fewer pkeys we use.
                                       Something to keep in mind...
     LOG_MSG_POLICY  bool              True iff log messages are
                                       required for this project.
     PUBLIC          bool              True iff this project allows
                                       anon access.

*** The COMMITS table

          This table is the last thing to get updated in a commit -- if you
          don't see it here, then the commit isn't done yet. (Actually, the
          timing issues may well be handled for free, if we use built-in
          database transaction support and the appropriately-named SQL
          "commit" command).

     PROJECT int [fkey] or string  Which project this commit belongs
             (never null)          to.
     VERSION int                   The version number of this commit.
             (never null)          Initial import gets 1.
     LOG_MSG text                  The log message for this commit.


*** The USERS table

     USERNAME           string  You know what this is.
     REALNAME           string  Same.
     EMAIL              string  Same.
     USE_SYSTEM         bool    Permit fall-back to system
                                authentication or not.
     PASSPHRASE or      ?       We're still figuring out how
     PUBLIC_KEY                 authentication works. We know that
                                repository users do not require
                                system accounts, at least.

*** The ACCESSES table

     USER        string        A username.
     PROJECT     int or        Projects this user is allowed to
                 string        access, and what kind of access is
                               allowed for each. Format to be
                               determined. (Referenced by fkey or
                               name? See similar discussions above.)
     ACCESS_TYPE ?             Format and meaning to be determined.
                               We can have anything from a simple
                               read-only vs read-write dichotomy, all
                               the way to listing the exact
                               operations that are permitted.

*** The INVERSION table

          Records a few server-specific things about this repository. Right
          now, we only know one column:

     IVN_RELEASE ? The release number (version, in the wider sense)
                   of the Inversion server that created or last
                   upgraded this repository. For compatibility: if we
                   add new columns, or new interpretations of old
                   columns, an upgraded server can tell what it needs
                   to do to upgrade the repository tables, for
                   example.


* Meta-implementation

This section describes the process of implementing Inversion -- what
order we do things in, and how.

The design needs to be evaluated across common operations, such as:
updating a project, updating <i>part</i> of a project, committing from
an up-to-date-working copy, committing from a non-up-to-date working
copy where the locally modified files are up-to-date, the same but
where the locally modified files are not up-to-date, the same but with
conflicts, tagging/branching, ... etc.  I am accumulating a list of
such operations; contributions welcome.

For each such operation, we need to step through what would happen in
the repository, so we'll discover bottlenecks in the design.

Once the design is ready, the parallizable parts of the software
should be determined, and tasks divvied up.  At this point or very
soon after, the client/server protocol needs to be designed too.  We
will evaluate WebDAV (using the same examination-under-common-ops
technique as with the data design); if WebDAV is suitable, it would be
a good choice, because it already has some political acceptability.

During the initial coding phase, everything that can be farmed out to
external programs will be.  For example, the diff routines will just
invoke xdelta and diff (or whatever), and the client side will invoke
an external patch.  In the long run, these things will very likely be
internalized for speed, but their semantics won't change when we do
that, and it's more important to get the stuff up and running as soon
as we can, and optimize afterwards.

There should be an automated test-suite.  It should not be written in
Bourne shell script (we can at least learn this lesson from CVS!).

Authentication questions will be put off until most of the software is
working, since they probably don't affect the rest of the design much.

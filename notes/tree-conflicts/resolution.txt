Status of this document:
  - First draft: needs review.
  - Many recipes insufficiently detailed. Some difficult to achieve.


Resolving Tree Conflicts
========================

This document sets out, for each type of tree conflict, the resolutions that I
expect would be commonly wanted, either giving a useful result directly or as
building blocks for more complex resolutions.

The aim is to provide in each of the selected cases a sufficiently clear
recipe for a user to resolve most tree conflicts that they encounter. Such a
user is expected to be fairly proficient in using Subversion but not to have
any knowledge of the way tree conflicts are handled internally.

Under each type of conflict are the following subsections:

  "WC State" describes the state in which the WC should be left when the
  conflict is raised, according to the principles set out below.

  "Some use cases" lists some likely use cases by which a user might encounter
  such a conflict, concentrating on cases that want a resolution other than
  "THEIRS" or "MINE".

  "Options" lists resolution options that ought to be available.  The
  resolution options "THEIRS" and "MINE" should be available in every case (so
  that a user can resolve a whole tree at once with one of those options) and
  should be implemented internally. Any other options listed here may be
  recipes for the user to apply manually. These recipes are starting from the
  state in which the WC should be left by Subversion after raising a conflict.

The "WC State" subsection is intended as design requirements, not for the end
user. I have not yet attempted to implement this as part of tree-conflict
detection, and have no idea to what extent this is currently achieved in the
tree-conflicts branch.

The other two subsections are intended as the basis of material for end users
to read.

Principles
----------

* We shall assume the ability to examine the source-left ("old") and source-
  right ("theirs") and target ("mine") tree states as well as the source
  diffs.

  In a merge, we shall not assume or attempt to make use of any ancestral
  relationship between the target and the source.

* When "svn update" or "svn switch" raises a tree conflict, it shall update
  the victim's "base" version from OLD to THEIRS, and leave the "working"
  version in a state that would be committable (but for the explicit check
  that prevents committing an item marked as in conflict) and that, if
  committed, would restore the item to how it looked in "mine". This may
  involve changing the scheduling of the item, e.g. to be re-added if "update"
  applied a delete.

  When "svn merge" raises a tree conflict, it shall not change the working
  content or scheduling of the victim.

* An update from rX to rY followed by an update back to rX should have no
  overall effect on the local modifications scheduled in the WC. Likewise a
  switch to a different URL@REV and a switch back to the original one.
  Likewise a merge followed by a merge of the reverse change.

Renames and Replacements
------------------------

An incoming rename is treated here as its two constituent actions - an
incoming delete and an incoming add - separately.

In an incoming replacement, the delete is assumed to come before the add.
(Currently, they may sometimes come the wrong way around. I have not analysed
the cases in which this can happen, nor the consequences.)

Where the ability to schedule a replacement of one node kind with another is
implied, this ability may not be supported (and currently is not supported) by
the working copy library. Such cases will therefor be unsupported. This is not
seen as a deficiency inherent in tree conflict handling, but as a separate
deficiency that restricts tree conflict handling in certain cases.

WC State
--------

WC State is defined in terms of what file content and what scheduling is
stored for each of ".working" (the active WC file/dir during resolving),
".mine" (the previous working file/dir, as preserved for reference), and
".theirs" (the type and resulting content of the incoming change).

Meaning of "Choose Theirs" and "Choose Mine"
--------------------------------------------

There is a subtle difference between the meanings of "Choose Theirs" and
"Choose Mine" as applied to an update or switch compared with when
the terms are applied to a merge.

For update and switch, the final state resulting from the incoming change is
already existing in the history of the branch we're working on, and is going
to be our WC's new "base" version, so we can't choose to "ignore" this
incoming change. The request to "Choose Mine" means "Schedule the item to be
changed from its new base state back to how my version of it looked before
this operation". This may involve changing the scheduling of the item. The
request to "Choose Theirs" simply means "Discard my pending changes so as to
keep their version of it".

For a merge, however, the final state of the incoming change is not going to
be the new base state of the branch we're working on, and so we _can_ choose
to ignore it if we so wish. Also, "my" version is a combination of historical
and working-copy changes, so we cannot in general choose to ignore this, we
can only schedule changes that reverse it. In a merge, then, "Choose Mine"
means "Leave my version of the item as it is" (which does not involve any
change of scheduling), while "Choose Theirs" means "Overwrite my version with
a copy of Their version of the item" (which may involve scheduling an add or
delete). The potential alternative meaning, "Make Their change", is not
viable: it is what Subversion already tried to do, and it resulted in the very
conflict we're now trying to resolve.


Tree Conflict Resolution Recipes
================================

up/sw: Add onto Add
-------------------

WC State:
  .working: sched=Normal/Replace, content=.mine
  .mine:    sched=Add[w/hist], content=Something
  .theirs:  action=Add[w/hist], content=Something

Some use cases:
  - I have already applied the patch - their item is identical to mine.
    -> want to do it just once -> THEIRS.
  - Two different new items happened to be given the same name.
    -> accept theirs & rename mine -> RENAME-MINE.
  - I was doing roughly the same thing but the file is a bit different.
    -> merge the two files -> manual 2-way merge.

Options:
  THEIRS: As usual, like "svn revert TARGET".
  MINE:   My content as a scheduled modification, or as a scheduled replace*
          if "my" node-kind (or copy-from?) differs.
  RENAME-MINE: Add "my" content under a different name, and then accept
          "their" add:
    - Choose a new name for mine.
    - svn rename TARGET NEWNAME
    - svn revert TARGET

If identical (node-kind, content, props, copyfrom-info?):
  Recommend choosing THEIRS.


up/sw: Del onto Del
-------------------

WC State:
  .working: sched=unversioned, content=None
  .mine:    sched=Del, content=None
  .theirs:  action=Del, content=None

Some use cases:
  - Already applied the patch
    -> want to do it just once -> THEIRS.
  - Renamed to two different names
    -> want to override Their renaming and make it like Mine, as if we had a
    "Choose Mine" option that worked on whole rename operations. Want RENAME.

Options:
  THEIRS: As usual (but has no effect in this case)
  MINE:   As usual (but has no effect in this case)
  RENAME:
    - svn rename THEIR-NEW-NAME MY-NEW-NAME
    And take care to notice if there were any modifications made at the same
    time as the renames; if so, these might need merging.

Note: In an update or switch, THEIRS and MINE are from the same OLD base, so
there is no possibility that the item we are deleting locally is different
from the item the incoming change is deleting.


up/sw: Mod onto Del
-------------------

WC State:
  .working: sched=Del, content=None
  .mine:    sched=Del, content=None
  .theirs:  action=Mod, content=Something

Some use cases:
  - Locally renamed
    -> want to apply the incoming mod to a different item -> ELSEWHERE.

Options:
  THEIRS: As usual.
  MINE:   Leave it deleted.
  ELSEWHERE:
    - Determine the incoming diff's revision numbers and URL.
    - svn merge -r OLDREV:NEWREV TARGET(URL?) NEWNAME


up/sw: Del onto Mod
-------------------

WC State:
  .working: sched=Add, content=.mine
  .mine:    sched=Normal, content=Something
  .theirs:  action=Del, content=None

Some use cases:
  - The incoming change is (part of) a rename
    -> want to transfer my local mod to the renamed item -> MOVE-MY-MODS.

Options:
  THEIRS: As usual.
  MINE:   Schedule for Add.
  MOVE-MY-MODS: Transfer my local mods into an item with a different name.
    - Determine their new name.
    - Wait till up/sw has processed the new-named item.
    - svn merge -r OLD:MINE TARGET THEIRNEWNAME [*1]
    - svn revert TARGET

Note [*1]: The kind of merge needed in MOVE-MY-MODS is not yet supported.


merge: Add onto Here (Identical or Different-Content or Different-Kind)
--------------------

WC State:
  .working: =.mine
  .mine:    sched=(not Del), content=Something
  .theirs:  action=Add[w/hist?], content=Something

Some use cases:
  Same as for "up/sw: Add onto Add".

Options:
  THEIRS: As usual: Schedule local mods (if any change needed) to make mine
    match theirs.
  MINE:   As usual: untouched.
  RENAME-MINE: Add "my" content under a new name, and then accept "their" add:
    - Choose a new name for mine.
    - svn move TARGET NEWNAME
    - svn copy TARGET.theirs TARGET  # svn merge -rOLD:THEIRS TARGET TARGET

If identical (node-kind, content, props, copyfrom-info?):
  Recommend choosing THEIRS.


merge: Del onto Nothing Here
----------------------------

WC State:
  .working: =.mine
  .mine:    sched=(Del/unversioned), content=None
  .theirs:  action=Del, content=None

Some use cases:
  - User's process is wrong: maybe something else needed to be merged first.
    -> want to revert this whole merge.
  - Already applied the patch or merged the change without recording the fact.
    -> want to do it once -> MINE.
  - The item being deleted (or renamed) in the source has been renamed in the
    target branch.
    -> want to delete/rename something else -> ELSEWHERE.

Options:
  THEIRS: Nothing to do - same result as MINE.
  MINE:   (Nothing to do.)
  ELSEWHERE: Leave TARGET as it is, and
    - Find the new name(s).
    - svn delete MYNEWNAME
      or
      svn rename MYNEWNAME THEIRNEWNAME


merge: Del onto Not Same Kind
-----------------------------

WC State:
  .working: =.mine
  .mine:    sched=(not Del), content=TheOtherKind
  .theirs:  action=Del, content=None

Some use cases:
  - User's process is wrong: maybe something else needed to be merged first.
    -> want to revert this whole merge.

Options:
  THEIRS:
    - svn delete TARGET
  MINE:   (Nothing to do.)


merge: Del onto Not Same Content
--------------------------------

WC State:
  .working: =.mine
  .mine:    sched=(not Del), content=SameKind
  .theirs:  action=Del, content=None

Some use cases:
  - The content was intentionally divergent, and we still want to delete it.
    -> THEIRS.
  - The content was intentionally divergent, and the source node is being
    renamed (and possibly modified at the same time).
    -> Apply the incoming rename (and possibly content mods) -> RENAME.

Options:
  THEIRS:
    - svn delete TARGET
  MINE:   (Nothing to do.)
  RENAME:
    - Find the new name.
    - Wait till the new name has been processed (added).
    - svn rename, merge, ...?


merge: Mod onto Nothing Here
----------------------------

WC State:
  .working: =.mine
  .mine:    sched=(Del/unversioned), content=None
  .theirs:  action=Mod, content=Something

Some use cases:
  - The item was renamed
    -> apply the mod elsewhere -> ELSEWHERE.

Options:
  THEIRS: Re-schedule the target to come back.
    - copy TARGET.theirs TARGET
    - svn add TARGET
  MINE:   (Nothing to do.)
  ELSEWHERE:
    - Find the new name.
    - Wait till the new name has been processed (added).
    - svn merge -r OLD:THEIRS TARGET NEWNAME [*1]


merge: Mod onto Not Same Kind
-----------------------------

WC State:
  .working: =.mine
  .mine:    sched=(not Del), content=TheOtherKind
  .theirs:  action=Mod, content=Something

Options:
  THEIRS: Not supported. Throw an error. (Want to schedule the target to
    replace with theirs, but WC doesn't support this.)
  MINE:   (Nothing to do.)


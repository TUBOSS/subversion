                                                                -*- Text -*-

Conflict meta data storage in wc-ng
===================================

Conflict meta data is stored in the ACTUAL_NODE table, within the
'conflict_data' column. The data in this column is a skel containing
conflict information, or NULL (meaning no conflict is present).

There are five types of conflicts (text conflicts, property conflicts,
tree conflicts, patch conflicts, and obstructions). The conflict skel
has the form:

  ((KIND OPERATION KIND-SPECIFIC) (KIND OPERATION KIND-SPECIFIC) ...)

where KIND is one of "text", "prop", "tree", "patch", or
"obstructed". OPERATION indicates the operation which caused
the conflict and is detailed below. KIND-SPECIFIC is specific
to each KIND, and is detailed below.

### stsp: need conflict data format version info inside skel, too?
###   or do we bump the entire wc.db format number if we need to tweak
###   this?
###
### gstein sez: the KIND can become "text-2" or somesuch if we need to
###   radically alter the kind-specific data. but we can easily append
###   information to the skel without much problem.

If the 'conflict_data' column is not NULL, then at least one
one KIND of conflict skel must exist, describing the conflict(s).

Contrary to wc-1, wc-ng records sufficient information to help users
understand, in hindsight, which operation led to the conflict (as long
as all conflict information is exposed by the UI).

Some information which wc-1 was storing in entries has no direct
equivalent in wc-ng conflict storage (such as paths to temporary files),
but this information can be deduced from the information stored
(e.g. conflict-old and friends; foo.r42 is now 'foo' + '.r' + left_rev)


Terminology
--------------------

There are 3 versions of an item involved in a conflict:
  left: During update, the 'left' version is the common ancestor
        of the 'right' and 'mine' versions.
        During merge, the 'left' version is the version of the item
        as it appears at the merge-left revision.
 right: During update, the 'right' version is the version of the item
        as it appears in the revision updated to.
        During merge, the 'right' version is the version of the item
        as it appears at the merge-right revision.
  mine: During both update and merge, this is the version of the item
        as found in the working copy when the conflict was detected
        (which does not necessarily equal the current working version!)



Operation skel
--------------

The OPERATION skel has the following form:

  (NAME OPERATION-SPECIFIC)

NAME is "update", "switch", "merge", or "patch".

OPERATION-SPECIFIC is as follows:

For update: (BASE_REV TARGET_REV)

  BASE_REV is the base revision prior to the update.
  TARGET_REV is the revision being updated to.

For switch: (BASE_REV TARGET_REV REPOS_ROOT_URL REPOS_RELPATH)

  REPOS_ROOT_URL is the repository root of the URL being switched to.
  REPOS_RELPATH is the path in the repository being switched to.

For merge:
  (LEFT_REV RIGHT_REV
   (LEFT_REPOS_UUID LEFT_REPOS_ROOT_URL LEFT_REPOS_RELPATH LEFT_PEG_REV)
   (RIGHT_REPOS_UUID RIGHT_REPOS_ROOT_URL RIGHT_REPOS_RELPATH RIGHT_PEG_REV) )

  LEFT_REV is the merge-left revision, and RIGHT_REV is the merge-right
    revision of a continuous revision range which was merged (merge tracking
    might split a merge up into multiple merges of continuous revision ranges).

  {LEFT,RIGHT}_REPOS_UUID is the UUID of the repository the {left,right}
    version of the item comes from, in order to recognize merges from foreign
    repositories.

  {LEFT,RIGHT}_REPOS_ROOT_URL is the repository root URL the {left,right}
    version of the item comes from.

  {LEFT,RIGHT}_REPOS_RELPATH is the path in the repository of the {left,right}
    version of the item.

  {LEFT,RIGHT}_PEG_REV is the peg revision of the {left,right} version
    of the item.

For patch: (PATCH_FILE_ABSPATH)

  PATCH_FILE_ABSPATH is the absolute path of the patch file the
  application of which led to conflicts.


Text conflicts
--------------

Text conflicts only exist on files. The following skel represents the
"text" KIND of conflict:

  ("text" LEFT_SHA1 RIGHT_SHA1 MINE_SHA1)

### BH: We need some marker here, but these values must also be stored
###     in the older_checksum, left_checksum, right_checksum colums of ACTUAL
###     to allow pristine store cleanups.

### BH: What about symlinks?
### stsp: I guess we can say that all SHA1 sums refer to proper files,
###   and symlinks are resolved before the SHA1 is calculated and
###   stored in the db?

{LEFT,RIGHT,MINE}_SHA1 are sha1 checksums of the full texts of
the {left,right,mine} version of the file. File version's content
can be obtained from the pristine store.


Property conflicts
--------------

Property conflicts can exist on files, directories and symlinks.
There can be one or more property conflicts on the node, represented
by one or more "prop" KIND conflicts. Each "prop" conflict has the
following form:

  ("prop" PROPERTY_NAME ([LEFT_VALUE]) ([RIGHT_VALUE]) ([MINE_VALUE]))

PROPERTY_NAME is the name of the property, such as "svn:eol-style".

Each property value ({LEFT,RIGHT,MINE}_VALUE) is represented as an
empty list indicating the property did not exist in that version, or a
1-item list containing the particular value.


Tree conflicts
--------------

Tree conflicts exist on files or directories.
The following information is stored if there is a tree conflict on the node:

  ("tree"
    INCOMING_CHANGE LOCAL_CHANGE
    LEFT_NODE_KIND RIGHT_NODE_KIND
    LEFT_SHA1 RIGHT_SHA1 MINE_SHA1)

INCOMING_CHANGE is the incoming change which conflicted with the
local change during the operation. Possible values are "edit", "add",
"delete", "rename", and "replace".

LOCAL_CHANGE is the local change which conflicted with the
incoming change during the operation. Possible values are "edit", "add",
"delete", "rename", "replace", "obstructed", and "missing".

If the {left,right,mine} version of the item is a file and the content
of that file is known, {LEFT,RIGHT,MINE}_SHA1 is the sha1 checksum of the
full text of the {left,right,mine} version of the file. The file version's
content can be obtained from the pristine store.

### BH: We need to duplicate the sha1 values in the older_checksum,
###     left_checksum, right_checksum columns of ACTUAL
###     to allow pristine store cleanups.

### BH: Can we share some of the sha1 logic with the text conflicts to
###     allow resolving this in the same way?
###     (We should keep the history of the node valid via replace vs update)
### stsp: I don't really understand your question. Can you be more specific?


(Unversioned) Obstructions
--------------------------

When an update introduces a new node where an existing unversioned node is
stored locally we need to add some marker to allow the operation to update
the BASE_NODE table.

There is no particular data which needs to be recorded for an
obstruction. Thus, the "obstructed" conflict skel has the form:

  ("obstructed")


Reject conflicts
----------------
For patches, the content of the left and right versions is not fully known,
so the conflict is not a diff3-style text conflict. Rather, the conflict
is the failure to find a match for a hunk's context in the patch target.

  ("reject"
    HUNK_ORIGINAL_OFFSET HUNK_ORIGINAL_LEN
    HUNK_MODIFIED_OFFSET HUNK_MODIFIED_LENGTH
    REJECT_DIFF_SHA1)

HUNK_{ORIGINAL,MODIFIED}_OFFSET and HUNK_{ORIGINAL,MODIFIED}_LENGTH
are the hunk header values as parsed from the patch file (i.e. the "ID"
of the hunk within the patch file). These also occur in the reject
diff text but are stored here for easy retrieval.

REJECT_DIFF_SHA1 is the sha1 of the unidiff content of the rejected
hunk as written to the .svnpatch.rej file. The actual unidiff content
(which can be large!) can be retrieved from the pristine store.

### BH: Using a sha1 here, makes it impossible to cleanup the pristine store
###     The pristine store needs all references to be stored in a DB column.
###     To support this we would need an extra table.
### stsp: I'm fine with not storing the reject diff text if we don't
###   have a good location for it. However, keeping it around in case
###   the user deletes the tempfile would be nice. And I don't see an issue
###   with also storing the SHA1 sum in the ACTUAL table. We do this for
###   text conflicts as well. Why would it need an extra table?

### gstein: why keep the PATCH_FILE_ABSPATH? couldn't that be rm'd at
###   some point after the attempted 'svn patch'? and doesn't this
###   obviate the future possibility of patch from stdin?
### stsp: See http://svn.haxx.se/dev/archive-2010-03/0645.shtml

                                                                -*- Text -*-

Conflict meta data storage in wc-ng
===================================

Conflict meta data is stored in the ACTUAL_NODE table, within the
'conflict_data' column. The data in this column is a skel containing
conflict information, or NULL (meaning no conflict is present).

There are five types of conflicts (text conflicts, property conflicts,
tree conflicts, reject conflicts, and obstructions). The conflict skel
has the form:

  ((KIND OPERATION KIND-SPECIFIC) (KIND OPERATION KIND-SPECIFIC) ...)

where KIND is one of "text", "prop", "tree", "reject", or "obstructed".
OPERATION indicates the operation which caused the conflict and is
detailed below. KIND-SPECIFIC is specific to each KIND, and is detailed
below.

### stsp: need conflict data format version info inside skel, too?
###   or do we bump the entire wc.db format number if we need to tweak
###   this?
###
### gstein sez: the KIND can become "text-2" or somesuch if we need to
###   radically alter the kind-specific data. but we can easily append
###   information to the skel without much problem.

If the 'conflict_data' column is not NULL, then at least one
KIND of conflict skel must exist, describing the conflict(s).

Contrary to wc-1, wc-ng records sufficient information to help users
understand, in hindsight, which operation led to the conflict (as long
as all conflict information is exposed by the UI).

Some information which wc-1 was storing in entries has no direct
equivalent in wc-ng conflict storage (such as paths to temporary files),
but this information can be deduced from the information stored
(e.g. conflict-old and friends; foo.r42 is now 'foo' + '.r' + left_rev)


Operation skel
--------------

The OPERATION skel has the following form:

  (NAME OPERATION-SPECIFIC)

NAME is "update", "switch", "merge", or "patch".

OPERATION-SPECIFIC is as follows:

To record an "update" operation, the skel has the form:

  ("update" BASE_REV TARGET_REV)

  BASE_REV is the base revision prior to the update.
  TARGET_REV is the revision being updated to.

For "switch", the skel has the form:

  ("switch" BASE_REV TARGET_REV REPOS_ROOT_URL REPOS_RELPATH)

  BASE_REV and TARGET_REV are as for "update" above.
  REPOS_ROOT_URL is the repository root of the URL being switched to.
  REPOS_RELPATH is the path in the repository being switched to.

For "merge", the skel has the form:

  ("merge" LEFT_REV RIGHT_REV
   (LEFT_REPOS_UUID LEFT_REPOS_ROOT_URL LEFT_REPOS_RELPATH LEFT_PEG_REV)
   (RIGHT_REPOS_UUID RIGHT_REPOS_ROOT_URL RIGHT_REPOS_RELPATH RIGHT_PEG_REV) )

  LEFT_REV is the merge-left revision, and RIGHT_REV is the merge-right
    revision of a continuous revision range which was merged (merge tracking
    might split a merge up into multiple merges of continuous revision ranges).

  {LEFT,RIGHT}_REPOS_UUID is the UUID of the repository the {left,right}
    version of the item comes from, in order to recognize merges from foreign
    repositories.

  {LEFT,RIGHT}_REPOS_ROOT_URL is the repository root URL the {left,right}
    version of the item comes from.

  {LEFT,RIGHT}_REPOS_RELPATH is the path in the repository of the {left,right}
    version of the item.

  {LEFT,RIGHT}_PEG_REV is the peg revision of the {left,right} version
    of the item.

### JAF: Don't want both "rev" and "peg-rev" separately: that's recording too
###   much UI.  Just have the revision in which to find the repos-relpath.
### stsp: Peg revs aren't just UI. You need them to uniquely identify an item
###   in the repository history. Here's an example for why we need them:
###   Say I'm doing a merge of range rA-rB, and within this range,
###   file foo.c is replaced in rN, and later renamed to bar.c in rM.
###   Of course, A < N < M < B.
###   (Note: The following highly depends on how editorv2 drivers will be
###    implemented, so I may be off-track here.)
###   During the merge with editorv2, the replace and rename result in the
###   addition of foo.c@N (replacing foo.c@A), and the move of foo.c@N
###   to bar.c. Let's say foo.c@A has edits local to the merge target.
###   I'd like flag a edit/replaced tree conflict, and record foo.c@rA as
###   the 'left' version of the conflicting item, and foo.c@rN as the 'right'
###   version. Recording foo.c@B is wrong because foo.c does not exist at
###   that revision, so being able to record just two revisions won't work.
###   We could also record bar.c@B as the 'right' version, but this doesn't
###   feel right since the rename does not really conflict with the edits.
###   The item which is being renamed is not the one which was edited -- it
###   just happened to live at the same path at a different time.

For "patch", the skel has the form:

  ("patch" PATCH_SOURCE_LABEL)

  PATCH_SOURCE_LABEL is (typically) the absolute path of the patch
  file the application of which led to conflicts. In the future, it
  may also be something like "<stdin>".


Text conflicts
--------------

Text conflicts only exist on files. The following skel represents the
"text" KIND of conflict:

  ("text" OPERATION LEFT_SHA1 RIGHT_SHA1 MINE_SHA1)

{LEFT,RIGHT,MINE}_SHA1 are sha1 checksums of the full texts of
the {left,right,mine} version of the file. File version's content
can be obtained from the pristine store.

### BH: We need some marker here, but these values must also be stored
###     in the older_checksum, left_checksum, right_checksum colums of ACTUAL
###     to allow pristine store cleanups.

### BH: What about symlinks?
### stsp: I guess we can say that all SHA1 sums refer to proper files,
###   and symlinks are resolved before the SHA1 is calculated and
###   stored in the db?


Property conflicts
--------------

Property conflicts can exist on files, directories and symlinks.
There can be one or more property conflicts on the node, represented
by one or more "prop" KIND conflicts. Each "prop" conflict has the
following form:

  ("prop" OPERATION
   PROPERTY_NAME ([LEFT_VALUE]) ([RIGHT_VALUE]) ([MINE_VALUE]))

PROPERTY_NAME is the name of the property, such as "svn:eol-style".

Each property value ({LEFT,RIGHT,MINE}_VALUE) is represented as an
empty list indicating the property did not exist in that version, or a
1-item list containing the particular value.


Tree conflicts
--------------

Tree conflicts exist on files or directories.
The following information is stored if there is a tree conflict on the node:

  ("tree" OPERATION
    INCOMING_CHANGE LOCAL_CHANGE
    LEFT_NODE_KIND RIGHT_NODE_KIND
    LEFT_SHA1 RIGHT_SHA1 MINE_SHA1)

INCOMING_CHANGE is the incoming change which conflicted with the
local change during the operation. Possible values are "edit", "add",
"delete", "rename", and "replace".

LOCAL_CHANGE is the local change which conflicted with the
incoming change during the operation. Possible values are "edit", "add",
"delete", "rename", "replace", "obstructed", and "missing".

If the {left,right,mine} version of the item is a file and the content
of that file is known, {LEFT,RIGHT,MINE}_SHA1 is the sha1 checksum of the
full text of the {left,right,mine} version of the file. The file version's
content can be obtained from the pristine store.

### BH: We need to duplicate the sha1 values in the older_checksum,
###     left_checksum, right_checksum columns of ACTUAL
###     to allow pristine store cleanups.

### BH: Can we share some of the sha1 logic with the text conflicts to
###     allow resolving this in the same way?
###     (We should keep the history of the node valid via replace vs update)
### stsp: I don't really understand your question. Can you be more specific?

### gstein suggests:
###
###   ("tree" OPERATION LOCAL_STATE INCOMING_STATE)
###
###   LOCAL_STATE := (LOCAL_CHANGE NODE_KIND [ORIGINAL_SHA1 MINE_SHA1])
###   INCOMING_STATE := (INCOMING_CHANGE NODE_KIND [INCOMING_SHA1])
###
### this groups the data better, and has nice (optional) placeholders
### for the SHA1 values when NODE_KIND is "file"


(Unversioned) Obstructions
--------------------------

When an update introduces a new node where an existing unversioned node is
stored locally we need to add some marker to allow the operation to update
the BASE_NODE table.

There is no particular data which needs to be recorded for an
obstruction. Thus, the "obstructed" conflict skel has the form:

  ("obstructed" OPERATION)


Reject conflicts
----------------
For patches, the content of the left and right versions is not fully known,
so the conflict is not a diff3-style text conflict. Rather, the conflict
is the failure to find a match for a hunk's context in the patch target.
There can be one or more reject conflicts on a node. Each "reject" conflict
has the following form:

  ("reject" OPERATION
    HUNK_ORIGINAL_OFFSET HUNK_ORIGINAL_LEN
    HUNK_MODIFIED_OFFSET HUNK_MODIFIED_LENGTH
    REJECT_DIFF_SHA1)

HUNK_{ORIGINAL,MODIFIED}_OFFSET and HUNK_{ORIGINAL,MODIFIED}_LENGTH
are the hunk header values as parsed from the patch file (i.e. the "ID"
of the hunk within the patch file). These also occur in the reject
diff text but are stored here for easy retrieval.

REJECT_DIFF_SHA1 is the sha1 of the unidiff content of the rejected
hunk as written to the .svnpatch.rej file. The actual unidiff content
(which can be large!) can be retrieved from the pristine store.

### BH: Using a sha1 here, makes it impossible to cleanup the pristine store
###     The pristine store needs all references to be stored in a DB column.
###     To support this we would need an extra table.
### stsp: I'm fine with not storing the reject diff text if we don't
###   have a good location for it. However, keeping it around in case
###   the user deletes the tempfile would be nice. And I don't see an issue
###   with also storing the SHA1 sum in the ACTUAL table. We do this for
###   text conflicts as well. Why would it need an extra table?

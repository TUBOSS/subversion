                                                                -*- Text -*-

Modularization of Code in WC-NG
===============================
###HKW: This section may someday want to live in libsvn_wc/README or some
such.  I'll leave that change until such time as we do the doc cleanup in
that library.

Update (2009-05-10): this section is completely out of date. wc-ng has
  not used this approach in its development. The primary "new" API
  layer is wc_db, and the redevelopment focuses around that.
###GJS: note that hwright has suggested we may want to find lines of
  division within wc_db. it is already quite large, and growing weekly.

Strict separation must be applied to a number of modules which can be
recognised.  This will help prevent spaghetti code as in wc-1.0 where
one piece of code manipulates paths to a working copy file, its URL
*and* the path to the base file.

For now, these APIs can be separated:

 - the public API (presumably not to be used by any internal
     processing, but presents functionality to working copy users)
#####XBC This is really required of all our module public APIs.
 - tree administration API (required for BASE, TARGET and WORKING)
     Admins which files are part of the tree, which ones map to
     which repositories and which textbase / propbase files belong
     to which local files. [should provide checkpointing functionality
     for use with transactional tree modifications API]
 - tree access API (required for BASE, WORKING, TARGET and ACTUAL)
     Gives access to the content of the nodes in a tree
       - props
       - text bases (for files)
       - child nodes (for directories)
 - transactional tree modifications API (applicable to all trees,
     ###EHU do we provide the same interface to BASE/WORKING as for ACTUAL?)
 - tree transformation (required for update/switch/merge updating
     BASE, WORKING and ACTUAL), meaning all of tree changes, file
     changes and metadata changes
 - Working-copy changedness detection API
 - Metadata access API (used by tree administration module(s))
 - Event hooks (in order to be able to implement different
   timestamp-setting strategies and possibly more)

These APIs will be implemented by these (currently known) modules:

 - tree administration
   * wc_adm
 - tree access
   * wc_acc
 - transactional tree modifications
   * wc_log
 - tree transformation
   * wc_trans
 - working copy changedness detection
   wc_detect vtable-based API implemented by these modules:
     * tree crawler ('inspired' by wc-1.0)
     * tree marker (inspired by 'p4 edit')
 - metadata access API
   wc_macc vtable-based API implemented by these modules:
     * tree spread ('inspired' by wc-1.0)
     * tree root (storing all metadata in the tree root (think darcs))
     * central depot (storing 'somewhere' locally, possibly $HOME)
        this central store would open up the possibility to share
        text bases/prop bases across checkouts
     * non-local (retrieving all text and prop-bases from the server,
        except for a number of cached ones) ###EHU: maybe this is
        orthogonal to the question where metadata is stored: in all
        situations, you *could* choose not to keep local copies
 - Event hooks for the union of all paths in (BASE, WORKING)
   wc_hook event based single-callback API
   for e.g. these events:
        + props updated
        + base text updated
        + wc file updated
        + update completed
        + lock acquired
        + lock released
       (+ lock can't be acquired [in order to 'unprotect'
           svn:needs-lock protected files which have been removed
           from the repository?])
   to be implemented by these modules:
     * use-commit-times
     * versioned-mtimes
     * versioned-execute-perm
     * versioned-other-unix-perms
    (* versioned-windows-perms?)
     * needs-lock-updater

Justification for the large number of modules, with a modest number
of different APIs is that the problem is really quite complex as shown
earlier in this document.

Over the years, a large number of use cases have developed around
Subversion where different user groups have shown very valid use cases
for conflicting behaviours.  Presumably, most of these we want to
retain.  Some of the unimplemented ones have open issues indicating
there's at least an active interest.  In order to prevent locking out
some of the current use cases adding support for the open issues, we
need a flexible modularized model.  This model will also prevent that
we'll end up duplicating lots of code to support the different use cases.
#####XBC Such flexibility will bring the WC to the kind of
         purgatory the RA layers are in. We promise feature and semantics
         parity between them, and the result is that even a small change
         in that layer requires knowledge of three different protocols
         and four different implementations.

Given the assumption of 'little code duplication', the choice for
having several modules which implement the same API (vtable) is
justifiable.

###GJS: disagree. I plan to have just one library and no plans for
   vtables. there is very little need for distinct implementations, as
   far as I can tell.

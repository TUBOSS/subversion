This directory contains work-in-progress materials for a new FS back
end to be implemented on top of a native filesystem.

At the time of this writing, nothing in this directory hooks into the
build system; not only is there no working code yet, but there isn't
support in Subversion for pluggable FS back ends yet.  (That work will
occur on a branch; after it is complete and merged into the trunk,
there will be something for code in this directory to plug into.)

Goals
-----

This project aims to generate a back end which has:

  * Low space overhead
  * Low administration requirements
  * Scalability to high read throughput and moderate write throughput
  * Flexibility of underlying file store; specifically:
    - Works on remote filesystems
    - Does not require write access for read-only operations
    - Committing does not require write access to existing revs
  * Simplicity
  * Robustness

To achieve these goals, the project may sacrifice:

  * Speed
  * Scalability to high write throughput

Design
------

This is a high-level design.  The details of the file formats and
layouts will be recorded in the file "structure".

Committed revisions are represented as a single file which never
changes.

Node-revisions are located by a revision number and an offset within
the revision file.

In contrast to the existing BDB back end, the contents of recent
revision of nodes will be stored as deltas against earlier revisions.
This is less efficient for common-case checkouts, but gives us greater
simplicity and robustness, as well as the flexibility to make commits
work without write access to existing revisions.  Skip deltas and
delta combination will mitigate the checkout cost.

In-progress transactions will be represented with a prototype rev flie
containing only the new text representations of files (appended to as
changed file contents come in) and an efficiently mutable
representation of the node-revisions, directory contents, and
property-lists which have been modified by the transaction so far.

To commit a transaction, the FS code must:

  * Perform an auto-merge against any new revs.
  * Grab a write lock on the repository.
  * Marshal the changed property lists, directory contents, and
    node-revisions onto the end of the rev file.
  * Move the new file into place.
  * Release the write lock.

(As a possible variation, we could grab the write lock one step later;
if a rev is committed between the auto-merge and the write lock, we
truncate the rev file back to the end of the text representation data
and go back to the beginning.  This would prevent large commits from
blocking small ones, but would also mean large commits could take a
long time to finalize.)

Workplan
--------

  1. Develop a straw-man revision file format.  It's not critically
     important to get it right on the first try, but it should be
     something that we think can efficiently support the libsvn_fs
     read APIs, including the ones related to node history.
     (Status: Done.)

  2. Write code to turn a (standard, not diffy) svn dump into the
     proposed file format.  This code will not survive the project,
     but will allow rapid generation of test cases.  At this point,
     the code should store all text representations against the empty
     base, and it can do stupid things like hold the entire directory
     structure of the head revision in memory.  It doesn't need to
     work incrementally.
     (Status: Done.)

  3. Write FS code to read, but not write, the file format, under the
     assumption that node-revs contain only deltas against the empty
     base.  Use the tool from (2) to generate test cases to ensure
     that the code works.
     (Status: Done.)

  4. Develop a format for the directory part of mutable transactions.
     (Status: Done.)

  5. Produce some test case transactions, either using an extension of
     the tool from (2) or by hand.
     (Status: Done.)

  6. Extend the read code from (3) to be able to read from unfinished
     transactions as well as from revision files.
     (Status: Done.)

  7. Write FS code to create and modify unfinished transactions.
     It can store node-rev contents in plain text.
     (Status: Done.)

  8. Write FS code to perform the auto-merge of an unfinished
     transaction and any revisions which have occurred since the
     transaction was created.
     (Status: Done.)

  9. Write FS code to commit an unfinished transaction by marshalling
     its changed-directory data onto the end of the changed-file data
     and moving the resulting file into place.
     (Status: Done.)

  10. Extend the tool from (2) to write out node-rev contents with
      base deltas, possibly using the code from (3) to determine the
      base contents to diff against.
      (Status: Done.)

  11. Extend the read code from (3) to handle delta bases using the
      delta combiner.

  12. Extend the write code from (7) and (9) to generate deltas with
      bases.

Not every step depends on the previous step, so not everything has to
proceed in order.

Known design issues
-------------------

Issue #1: Push/pull between svn_fs_apply_text[delta] and svn_txdelta
(Status: Resolved.)

When building a transaction, we will most likely want to streamily
generate a delta against the appropriate base and write it into the
transaction.  However, the target data is not available in the form of
a readable stream; it arrives in chunks from the caller after
svn_fs_apply_text[delta] returns.  svn_txdelta demands both source and
target data in the form of a readable stream, and supplies a readable
stream of delta windows.

Solution: We will need a variant which returns a writable stream for
the target data, and accepts a window handler instead of returning a
stream of delta windows.  This should be easy to implement; we just
have to redo the window handling code (which is short), and can still
invoke the same core vdelta engine code.

Issue #2: Avoiding long delays with no feedback during commit

As we've seen with deltification in the BDB implementation, it isn't
okay to do lots of work in one step of a commit.  Fundamentally,
though, it's potentially a lot of work to turn an easily mutable
representation of a transaction into a compact-but-immutable revision
file.  If we do all this work during the last phase of a commit, not
only may the user become impatient, but the HTTP client code may time
out.

Solution A: Write new text representations into the proto-revision
file as they arrive.  During the last phase of a commit, marshal the
changed properties, changed directory data, and changed node-rev data
into the end of the rev file.  This solution was Greg's original plan,
but it has been criticized half-measure: it introduces permanent waste
if a file is modified more than once during a single transaction, and
a large commit could still result in an HTTP timeout just from
marshalling the metadata onto the rev file.

Solution B: During the final phase of the commit, write out a stub rev
file which references the transaction directory.  In the same place in
the code as we currently do deltification, condense the transaction
into a rev file and then delete the transaction directory.
Transaction-condensing has to proceed in order, but that's not a big
deal since waiting for the previous transaction to condense can also
happen in the background.  This complicated solution introduces two
sub-problems.  First, if another commit starts before the current one
is condensed, pointers to the current revision will have to be done by
<rev, path> rather than by <rev, offset>.  (<rev, path> pointers can
be resolved inside either transaction directory or a rev file, but are
somewhat slower to resolve inside a rev file.)  Second, if readers may
be accessing a transaction directory, we can't be sure when it is okay
to delete one, since we axiomatically have no read locks.

Non-solution C: Try to solve the problem at the protocol level,
allowing us to send progress notifications even when nothing has
happened from the caller's point of view.  Particularly for HTTP, this
solution seems intractable, although it would provide a lot of future
flexibility for filesystem implementations.

Non-solution D: Rewrite the svn_fs API so that changes have to occur
in depth-first order.  (Essentially, use the editor interface.)  This
would let us represent transactions mostly as just partial rev files
(storing just a single stack of nested changed-directory data
alongside), but DAV really needs the flexibility of the current svn_fs
API, so it's not a starter.

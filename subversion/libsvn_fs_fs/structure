This is a placeholder for a file describing file formats and layouts.
For the moment, it just describes in general terms the decisions we
have to make.

See the "Design" section of the README file for a design overview.

Layout of the FS directory
--------------------------

We will need:

  * A naming scheme for revision files (probably the obvious one)
  * A naming scheme for rev-prop files
  * A way of quickly determining the most recent revision
  * A lockfile to grab during the final part of a commit
  * A way of naming transaction directories

(Rev-props must live in a separate file from the immutable part of
revisions so that they can be atomically replaced without rewriting
the entire rev file.)

Revision file format
--------------------

A revision file contains a concatenation of various kinds of data:

  * Text representations
  * Property lists
  * Node-revisions
  * At the end, the changed-path data
  * Two offsets at the very end

A text rep begins with a line containing either "PLAIN\n" or "DELTA\n"
or "DELTA <rev> <offset> <length>\n", where <rev>, <offset>, and
<length> give the location of the delta base of the representation and
the amount of data it contains (not counting the header or trailer).
If no base location is given for a delta, the base is the empty
stream.  After the initial line comes raw svndiff data, followed by a
cosmetic trailer "END\n".

The representation of a property list is the hash dump format used by
svn_hash_read and svn_hash_write.

The marshalling syntax for node-revs is a series of fields terminated
by a blank line.  Fields have either the syntax "<name>: <value>\n" or
"<name>:<length>:<value>\n", where <name> is a symbolic field name
(each symbolic name is used only once in a given node-rev), <length>
is the length of the value if given (not including the cosmetic
newline), and <value> is the value data.  If no length is given, the
value must contain no newlines.  Unrecognized fields are ignored, for
extensibility.  The following fields are defined:

  id        The ID of the node-rev
  type      "file" or "dir"
  pred      "<rev> <offset>" giving location of predecessor node-rev
  count     Count of node-revs since the base of the node
  rep       "<rev> <offset> <length> <size>"
            <rev> and <offset> give location of rep
            <length> gives length of rep, sans header and trailer
            <size> gives size of expanded rep
  props     "<rev> <offset>" giving location of property list
  cpath     FS pathname node was created at
  copyfrom  "{soft|hard} <rev> <path>" of copyfrom data
  copyroot  "<rev> <offset>" giving location of root of copy

The predecessor of a node-rev crosses copy history; together with the
count field, it allows efficient determination of the base for
skip-deltas.  The first node-rev of a node contains no "pred" field.
In a node-revision resulting from a copy, the "copyfrom" field gives
the copyfrom data; in other node-revs, the "copyroot" field gives the
location of the root of the copy.  (Note that since copy IDs are
initially inherited from parent directory to child, the root of a
node-rev's copy may belong to a different node, perhaps of a different
type, than the node-rev itself does.)

A node-revision with no properties may omit the "props" field.

[Don't know how changed-path data is represented yet.]

At the very end of a rev file is a line "<root-offset> <cp-offset>\n",
where <root-offset> is the offset of the root directory node revision
and <cp-offset> is the offset of the changed-path data.

All numbers in the rev file format are unsigned and are represented as
ASCII decimal.

Directory format
----------------

The text representation of a directory node is structured data in the
form of a dumped hash map (a la svn_hash_write).  The value of each
key is a string "<kind> <id> <rev> <offset>", where <kind> is "file"
or "dir", <id> is the ID of the node-rev pointed to by the directory
entry, and <rev> and <offset> give the location of the node-rev
pointed to by the directory.

Transaction layout
------------------

The transaction layout needs to have easily mutable directories, but
also quickly transformable into a rev file.  So we store changed-file
data into a prototype rev file, and changed-directory data in a
directory tree which mirrors the changed part of the transaction.
Each changed directory will contain a special file for directory
property changes, a file for each changed file underneath it
(containing the offset and ID of the file's new node-rev) and a
subdirectory for each changed directory underneath it.

This is a placeholder for a file describing file formats and layouts.
For the moment, it just describes in general terms the decisions we
have to make.

See the "Design" section of the README file for a design overview.

Layout of the FS directory
--------------------------

We will need:

  * A naming scheme for revision files (probably the obvious one)
  * A naming scheme for rev-prop files
  * A way of quickly determining the most recent revision
  * A lockfile to grab during the final part of a commit
  * A way of naming transaction directories

(Rev-props must live in a separate file from the immutable part of
revisions so that they can be atomically replaced without rewriting
the entire rev file.)

Revision file format
--------------------

A revision file contains a concatenation of various kinds of data:

  * Text representations
  * Property lists
  * Node-revisions
  * At the end, the changed-path data
  * Two offsets at the very end

A text representation begins with a line "REP <length> [<base-rev>
<base-offset>]\n" where <length> gives the length of the ensuing
svndiff data, and <base-rev> and <base-offset>, if present, give the
location of the delta base of the representation.  If no base location
is given, the base is the empty stream.  After the initial line comes
raw svndiff data, followed by a cosmetic marker "END\n".

The representation of a property list is the hash dump format used by
svn_hash_read and svn_hash_write.

The marshalling syntax for node-revs is a series of fields terminated
by a blank line.  Fields have either the syntax "<name>: <value>\n" or
"<name>:<length>:<value>\n", where <name> is a symbolic field name
(each symbolic name is used only once in a given node-rev), <length>
is the length of the value if given (not including the cosmetic
newline), and <value> is the value data.  If no length is given, the
value must contain no newlines.  Unrecognized fields are ignored, for
extensibility.  The following fields are defined:

  id        The ID of the node-rev
  type      "file" or "dir"
  pred      "<rev> <offset>" giving location of predecessor node-rev
  count     Count of node-revs since the base of the node
  rep       Offset of text representation
  props     Offset of property list
  copyfrom  "{soft|hard} <rev> <path>" of copyfrom data
  copyroot  "<base> <offset>" giving location of root of copy
  cpath     FS pathname node was created at [clarify]

The predecessor of a node-rev crosses copy history; together with the
count field, it allows efficient determination of the base for
skip-deltas.  The first node-rev of a node contains no "pred" field.
In a node-revision resulting from a copy, the "copyfrom" field gives
the copyfrom data; in other node-revs, the "copyroot" field gives the
location of the root of the copy.  (Note that since copy IDs are
initially inherited from parent directory to child, the root of a
node-rev's copy may belong to a different node, perhaps of a different
type, than the node-rev itself does.)

[Don't know how changed-path data is represented yet.]

At the very end of a rev file is a line "<root-offset> <cp-offset>\n",
where <root-offset> is the offset of the root directory node revision
and <cp-offset> is the offset of the changed-path data.

All numbers in the rev file format are unsigned and are represented as
ASCII decimal.

Directory format
----------------

The text representation of a directory node is structured data in the
form of a dumped hash map (a la svn_hash_write).  The value of each
key is a string "<kind> <id> <rev> <offset>", where <kind> is "file"
or "dir", <id> is the ID of the node-rev pointed to by the directory
entry, and <rev> and <offset> give the location of the node-rev
pointed to by the directory.

Transaction layout
------------------

The transaction layout needs to have easily mutable directories, but
also quickly transformable into a rev file.  So we store changed-file
data into a prototype rev file, and changed-directory data in a
directory tree which mirrors the changed part of the transaction.
Each changed directory will contain a special file for directory
property changes, a file for each changed file underneath it
(containing the offset and ID of the file's new node-rev) and a
subdirectory for each changed directory underneath it.

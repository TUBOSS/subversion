     Oh Most High and Fragrant Emacs, please be in -*- text -*- mode!

This is the library described in the section "The working copy
management library" of svn-design.texi.

It performs local operations in the working copy, tweaking
administrative files and versioned data, generally in response to a
received delta.  It communicates with the server through libsvn_cl.

The Problem We're Solving.
==========================

The working copy is arranged as a directory tree, which, at checkout,
mirrors a tree rooted at some node in the repository.  Over time, the
working copy accumulates uncommitted changes, some of which may affect
its tree layout.  By commit time, the working copy's layout could be
arbitrarily different from the repository tree on which it was based.

Furthermore, even after an update/commit, the working copy and the
repository are not necessarily perfect mirrors, since the entire tree
is not always involved (thus local changes and local out-of-datenesses
can remain).

To resolve all situations safely, we must carefully define what is a
conflict between repository and working copy, and describe how such
conflicts are resolved.

Kinds of Changes.
=================

As their trees change over time, the working copy and repository each
track changes to files and directories.  There are two kinds of
changes, "direct" and "indirect":

               Direct Change        Indirect Change
          ._____________________._____________________.
          | Change to file's    |                     |
   file   | contents; OR, file  |                     |
          | was added, removed, |  [No such thing]    |
          | or renamed          |                     |
          |_____________________|_____________________|
          |                     |  An immediate child |
   dir    | This dir was added, |  of this dir was    |
          | removed, or renamed |  added, removed, or |
          |                     |  renamed            |
          |_____________________|_____________________|

In other words, a change that directly affects an entity's textual
contents or its existence is a "direct" change.  A change that affects
the existence of an entity's immediate child is an "indirect" change
to that entity (although it's a direct change to the child, of
course).  Only directories can have indirect changes, therefore.

Comparing Changes.
==================

In both commits and updates, the client and server compare changes in
the working copy against changes in the repository.  For commits, the
comparison is part of the pre-commit up-to-date check; for updates,
the comparison determines what changes will be sent from server to
client.

Since commits do not change the working copy, pre-commit checks do not
do intelligent conflict checking and merging.  They are only concerned
with whether the working copy's entities are up-to-date -- that is,
whether there have been divergent changes on the same entities in both
the working copy and the repository.  If so, then the working copy is
out-of-date.

Updates, on the other hand, can affect the working copy.  Updates
merge changes into the working copy where possible (not only textual
changes, but tree-structure changes), and signal a conflict wherever
merging is not possible.

Below, we describe

  * How the working copy describes its state to the server.

  * In the case of a commit,
       a) how the server uses this state to perform a pre-commit check.
       b) how the client completes the commit.

  * In the case of an update,
       a) how the server uses this state to generate an update delta.
       b) how the client applies an update delta.


How the working copy describes its state to the server.
=======================================================

The problem of describing the working copy's state to the server is
the same whether for pre-commit check or for update.  Both involve
some subset of the working copy (the subset could be everything in the
working copy, or it could be a selection of files and directories).
The client sends this subset to the server as a "snapshot", and the
server uses the snapshot to figure out how to respond to the client.

For the moment, let's tree the snapshot as a kind of black box (in
practice, it's probably a skelta, but that's not a requirement).  The
black box contains a number of entries, each one containing

   Original Name
   Original Version   (i.e., "base" version)
   Action             (content change, add, remove, rename...)
   New Name           (if any)
   Later Version      (only if other than repository latest)









 (i.e., what gets merged vs what is
     flagged as a conflict, and especially what the verb "flag as a
     conflict" *means* in different kinds of conflicts).

WC State
R State
conflict

Def: Modifying a file's contents is a "direct change" to that file.

Def: A rename, add, or delete is considered a direct change to the
      target(s), and an "indirect change" to the parent(s).

Def: A working copy's "WC state" is a snapshot (maybe a skelta?) that
      shows the base versions, and any changes, for all entities in

Def: given a WC state, the repository could
      theoretically reconstruct the entire working copy, except for
      the actual content of uncomitted local changes.)
      [Define the black box way drawn on the board?]

Def: A "R state" is a list of all entities that have changed in the
      repository *relative* to a given WC state.  The repository can
      calculate the R state for a given a WC state.

Def: A WC state and a R state "conflict" iff they have any
      conflicting changes -- defined in (F) below.

Def: Changes conflict according to the following rules:

         - Two direct changes to the same entity always conflict.

         - An indirect and a direct change to the same entity conflict
           iff the direct change affects the entity's type (e.g., wc
           modifies foo/bar.c, but in the repository foo has been
           changed to a regular file).

         - Two indirect changes to the same entity never conflict.
           ??? or just if same name ???

         - Changes to different entities never conflict.

Def: The server never accepts a delta based on a WC state that
      conflicts with the repository.  The client is always responsible
      for sending non-conflicting deltas.

Given these principles [though see footnote 1], the process for
updates is largely the same as for commits, so the two are described
together here:

   1. The working copy creates a snapshot (W) of its state, and sends
      it to the server.

   2. The server checks if the entities listed in W have changed in
      the repository too [see footnote 2].  If there are no conflicts,
      then the commit is registered and a token sent back (or, if this
      is an update, the server sends back the appropriate delta).

   3. If there is a conflict, then...

         - commit case:
             Server sends back a message telling the working
             copy it must update.  By principle (G), the client can
             only commit based on a non-conflicting state, therefore
             the client must not only update, but also resolve any
             conflicts, before it can successfully commit.

         - update case:
             Well, this is where all the hardship happens. :-)

             First, a definition: "conflict-to-date" is when a working
             copy is up-to-date wherever there are no conflicts, but
             reflects both sides of the conflict wherever there *are*
             conflicts.

             The Subversion server tries, but is not required, to
             compute a delta that will bring the working copy
             conflict-to-date.  When it can do so, it sends this delta
             to the client, which then makes its working copy be
             conflict-to-date and leaves resolution to the user (same
             as CVS).

             However, for complex tree-structure conflicts, there is
             often no way to reflect both sides of the conflict in the
             working copy without being more confusing than helpful
             anyway.  How does one put "conflict markers" into a
             directory, especially when what was a directory might now
             be a file, or vice-versa?  For purely textual conflicts,
             CVS found a useful way to overlay the conflicting areas
             in all cases; if there is a similar overlay method for
             arbitrarily changed directory trees, I don't know what it
             is. :-)

             Therefore, an acceptable response from the Subversion
             server is: "Your working copy is too out of whack; please
             move it aside, check out a fresh one, redo your changes
             in the fresh copy, and commit from that."  (This response
             may apply to subtrees of the working copy, of course).

             The response will probably include more detail than that,
             of course.  In addition to the general out-of-whackness
             message, it can say "Directory foo was renamed to bar,
             conflicting with your new file bar; file blah was
             deleted, conflicting with your local change to file blah,
             ..." and so on.  The important thing is that these are
             informational only -- they're not changing the working
             copy, they're just telling the user what to examine when
             she syncs up two working trees manually.

             Subversion implements a _simple_ conflict-to-date delta
             generation algorithm initially.  It can improve as we get
             smarter and/or as there is demand for more informative
             conflicting updates.

--------------------------- Footnotes -----------------------------------

[1] Haven't thought carefully about whether this all works smoothly
when directory *entries* are considered entities.  I think so, but am
not sure yet.

[2] The working copy doesn't always want to compare against the pure
latest version in the repository -- it may be comparing against some
other version, or perhaps even different versions for different parts.
In fact, every entity in the working copy snapshot might have a
different "latest" to compare against, in addition to the possiblity
of a different base version.  I haven't thought about this carefully
yet either, but see no reason the snapshots can't include both sides
of the comparison for each entity.
